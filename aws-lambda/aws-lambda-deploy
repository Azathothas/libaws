#!/usr/bin/env python3.6
import base64
import json
import argh
import cli_aws
import sys
import os
import shell
import boto3
from util.retry import retry

def _parse_file(path):
    path = os.path.abspath(path)
    if not os.path.isfile(path):
        print('no such file:', path, file=sys.stderr)
        sys.exit(1)
    if not path.endswith('.py') or len(path.split('.py')) > 2:
        print('usage: python deploy.py some_lambda_file.py', file=sys.stderr)
        sys.exit(1)
    with open(path) as f:
        lines = f.read().splitlines()
    return path, lines, {"policies": cli_aws.parse_metadata('policy:', lines),
                         "allows": cli_aws.parse_metadata('allow:', lines),
                         "requires": [os.path.expanduser(x) for x in cli_aws.parse_metadata('require:', lines)],
                         "triggers": cli_aws.parse_metadata('trigger:', lines)}

def _ensure_triggers_api(name, arn_lambda, metadata):
    print('\nensure triggers api', file=sys.stderr)
    for trigger in metadata['triggers']:
        if trigger.split()[0] == 'api':
            rest_api_id = cli_aws.rest_api_id(name)
            if rest_api_id:
                print(' rest api already exists', file=sys.stderr)
            else:
                print(' create rest api', file=sys.stderr)
                rest_api_id = boto3.client('apigateway').create_rest_api(name=name, endpointConfiguration={'types': ['REGIONAL']})['id']
            parent_id = cli_aws.rest_resource_id(rest_api_id, '/')
            resource_id = cli_aws.rest_resource_id(rest_api_id, f'/{name}') # TODO child resource wildcard /name/{proxy+}
            if not resource_id:
                resource_id = boto3.client('apigateway').create_resource(restApiId=rest_api_id, parentId=parent_id, pathPart=name)['id']
            api = boto3.client('lambda').meta.service_model.api_version
            uri = f"arn:aws:apigateway:{cli_aws.region()}:lambda:path/{api}/functions/"
            uri += f'arn:aws:lambda:{cli_aws.region()}:{cli_aws.account()}:function:{name}/invocations'
            for resource_id in [parent_id, resource_id]:
                for method in ['ANY']:
                    try:
                        boto3.client('apigateway').put_method(restApiId=rest_api_id,
                                                              resourceId=resource_id,
                                                              httpMethod=method,
                                                              authorizationType='NONE')
                    except boto3.client('apigateway').exceptions.ConflictException:
                        pass
                    else:
                        boto3.client('apigateway').put_integration(restApiId=rest_api_id,
                                                                   resourceId=resource_id,
                                                                   httpMethod=method,
                                                                   type="AWS_PROXY",
                                                                   integrationHttpMethod='POST',
                                                                   uri=uri)
            boto3.client('apigateway').create_deployment(restApiId=rest_api_id, stageName=name)
            arn = f"arn:aws:execute-api:{cli_aws.region()}:{cli_aws.account()}:{rest_api_id}/*/*/{name}"
            _ensure_permission(name, 'apigateway.amazonaws.com', arn)

def _ensure_triggers_cloudwatch(name, arn_lambda, metadata):
    print('\nensure triggers cloudwatch', file=sys.stderr)
    for trigger in metadata['triggers']:
        if trigger.split()[0] == 'cloudwatch':
            _, schedule = trigger.split(None, 1)
            print(' ensure cloudwatch rule:', schedule, file=sys.stderr)
            arn_rule = boto3.client('events').put_rule(Name=name, ScheduleExpression=schedule)['RuleArn']
            _ensure_permission(name, 'events.amazonaws.com', arn_rule)
            targets = retry(boto3.client('events').list_targets_by_rule)(Rule=name)['Targets']
            assert all(t['Arn'] == arn_lambda for t in targets), f'there are unknown targets in cloudwatch rule: {name}'
            if len(targets) == 0:
                print(' add cloudwatch target', file=sys.stderr)
                boto3.client('events').put_targets(Rule=name, Targets=[{'Id': '1', 'Arn': arn_lambda}])
            elif len(targets) == 1:
                print(' cloudwatch target for rule already exists', file=sys.stderr)
            elif len(targets) > 1:
                print(' extra cloudwatch target found, removing them', file=sys.stderr)
                targets = sorted(targets, key=lambda x: x['Id'])
                boto3.client('events').remove_targets(Rule=name, Ids=[t['Id'] for t in targets[1:]])
            def ensure_only_one_target():
                targets = retry(boto3.client('events').list_targets_by_rule)(Rule=name)['Targets']
                assert len(targets) == 1, f'more than one target found for cloudwatch rule: {name}'
            retry(ensure_only_one_target, exponent=1.1)()

def _ensure_permission(name, principal, arn):
    try:
        statements = [x['Sid'] for x in json.loads(boto3.client('lambda').get_policy(FunctionName=name)['Policy'])['Statement']]
    except boto3.client('lambda').exceptions.ResourceNotFoundException:
        statements = []
    id = principal.replace('.', '-')
    if id in statements:
        print(' trigger permission already exists', file=sys.stderr)
    else:
        print(' add trigger permission:', principal, file=sys.stderr)
        boto3.client('lambda').add_permission(FunctionName=name,
                                              StatementId=id,
                                              Action='lambda:InvokeFunction',
                                              Principal=principal,
                                              SourceArn=arn)

def _ensure_triggers_sns(name, arn_lambda, metadata):
    print('\nensure triggers sns', file=sys.stderr)
    if 'sns' in metadata['triggers']:
        arn_sns = boto3.client('sns').create_topic(Name=name)['TopicArn']
        print('arn-sns:', arn_sns)
        boto3.client('sns').subscribe(TopicArn=arn_sns,
                                      Protocol='lambda',
                                      Endpoint=arn_lambda)
        _ensure_permission(name, 'sns.amazonaws.com', arn_sns)

def _all_keys():
    return [alias for page in boto3.client('kms').get_paginator('list_aliases').paginate() for alias in page['Aliases']]

def _key_id(key):
    return key['AliasArn'].split(':alias/')[0] + f':key/{key["TargetKeyId"]}'

def _ensure_key(name, arn_user, arn_role):
    print('\nensure kms key:', name, file=sys.stderr)
    keys = [x for x in _all_keys() if x['AliasArn'].endswith(f':alias/lambda/{name}')]
    if 0 == len(keys):
        arn_root = ':'.join(arn_user.split(':')[:-1]) + ':root'
        policy = """
        {"Version": "2012-10-17",
         "Statement": [{"Sid": "Enable IAM User Permissions",
                        "Effect": "Allow",
                        "Principal": {"AWS": ["%(arn_user)s", "%(arn_root)s"]},
                        "Action": "kms:*",
                        "Resource": "*"},
                       {"Sid": "Allow use of the key",
                        "Effect": "Allow",
                        "Principal": {"AWS": ["%(arn_user)s", "%(arn_role)s", "%(arn_root)s"]},
                        "Action": ["kms:Encrypt", "kms:Decrypt", "kms:ReEncrypt*", "kms:GenerateDataKey*", "kms:DescribeKey"],
                        "Resource": "*"},
                       {"Sid": "Allow attachment of persistent resources",
                        "Effect": "Allow",
                        "Principal": {"AWS": ["%(arn_user)s", "%(arn_role)s", "%(arn_root)s"]},
                        "Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
                        "Resource": "*",
                        "Condition": {"Bool": {"kms:GrantIsForAWSResource": true}}}]}
        """ % {'arn_role': arn_role,
               'arn_user': arn_user,
               'arn_root': arn_root}
        key_id = retry(boto3.client('kms').create_key, exponent=1.1, silent=True)(Policy=policy, Description=name)['KeyMetadata']['KeyId']
        boto3.client('kms').create_alias(AliasName=f'alias/lambda/{name}', TargetKeyId=key_id)
        keys = [x for x in _all_keys() if x['AliasArn'].endswith(f':alias/lambda/{name}')]
        assert len(keys) == 1
        print(' created key:', keys[0]['AliasArn'], file=sys.stderr)
        return _key_id(keys[0])
    elif 1 == len(keys):
        print(' key already exists:', keys[0]['AliasArn'], file=sys.stderr)
        return _key_id(keys[0])
    else:
        print(' error: found more than 1 key for:', name, '\n' + '\n'.join(keys), file=sys.stderr)
        sys.exit(1)

def _zip_file(path):
    name = cli_aws.lambda_name(path)
    return f'/tmp/{name}/lambda.zip'

def _create_zip(path, requires):
    print('\ncreate zip', file=sys.stderr)
    zip_file = _zip_file(path)
    tempdir = os.path.dirname(zip_file)
    shell.run('rm -rf', tempdir)
    shell.run('mkdir -p', tempdir)
    shell.run(f'virtualenv --python python3.6 {tempdir}/env')
    if requires:
        with shell.cd(os.path.dirname(path)):
            shell.run(f'{tempdir}/env/bin/pip install', *requires, '2>/dev/null')
    with shell.cd(f'{tempdir}/env/lib/python3.6/site-packages'):
        shell.run(f'cp {path} .')
        shell.run('rm -rf wheel pip setuptools pkg_resources easy_install.py')
        shell.run("ls | grep -E 'info$' | xargs rm -rf")
        shell.run(f'zip -r {zip_file} .')
    with open(zip_file, 'rb') as f:
        val = f.read()
    return val

def _update_zip(path):
    print('\nupdate code', file=sys.stderr)
    zip_file = _zip_file(path)
    tempdir = os.path.dirname(zip_file)
    with shell.cd(f'{tempdir}/env/lib/python3.6/site-packages'):
        shell.run(f'cp {path} .')
        shell.run(f'zip {zip_file} {os.path.basename(path)}')
    with open(zip_file, 'rb') as f:
        val = f.read()
    return val

def _encrypt(key_id, text):
    text = bytes(text, 'utf-8')
    text = boto3.client('kms').encrypt(KeyId=key_id, Plaintext=text)['CiphertextBlob']
    return base64.b64encode(text).decode('utf-8')

def _ensure_key_allows_role(arn_key, arn_role):
    resp = boto3.client('kms').get_key_policy(KeyId=arn_key, PolicyName='default')
    policy = json.loads(resp['Policy'])
    # ensure that every Statement.Principal.AWS is a list, it can be either a
    # string or a list of strings.
    for statement in policy['Statement']:
        if statement.get('Principal', {}).get('AWS'):
            if isinstance(statement['Principal']['AWS'], str):
                statement['Principal']['AWS'] = [statement['Principal']['AWS']]
    # remove invalid principals from all statements, these are caused by the
    # deletion of an iam role referenced by this policy, which transforms the
    # principal from something like "arn:..." to "AIEKFJ...".
    for statement in policy['Statement']:
        if statement.get('Principal', {}).get('AWS'):
            for arn in statement['Principal']['AWS'].copy():
                if not arn.startswith('arn:'):
                    statement['Principal']['AWS'].remove(arn)
    # ensure that the "allow use of key" Statement contains our role's arn
    for statement in policy['Statement']:
        if statement['Sid'] == 'Allow use of the key':
            if arn_role not in statement['Principal']['AWS']:
                statement['Principal']['AWS'].append(arn_role)
            break
    # if an "allow use of key" Statement didn't exist, create it
    else:
        policy['Statement'].append({
            "Sid": "Allow use of the key",
            "Effect": "Allow",
            "Principal": {"AWS": [arn_role]},
            "Action": ["kms:Encrypt", "kms:Decrypt", "kms:ReEncrypt*", "kms:GenerateDataKey*", "kms:DescribeKey"],
            "Resource": "*"
        })
    try:
        retry(boto3.client('kms').put_key_policy, silent=True, exponent=1.1)(KeyId=arn_key, Policy=json.dumps(policy), PolicyName='default')
    except boto3.client('kms').exceptions.MalformedPolicyDocumentException:
        print(f'failed to put to key: {arn_key}, policy:\n' + json.dumps(policy, indent=2), file=sys.stderr)
        raise

def _ensure_log_group(name):
    name = f'/aws/lambda/{name}'
    try:
        boto3.client('logs').create_log_group(logGroupName=name)
        print('created log group:', name, file=sys.stderr)
    except boto3.client('logs').exceptions.ResourceAlreadyExistsException:
        print('log group already exists:', name, file=sys.stderr)

def _set_concurrency(name, concurrency):
    if concurrency:
        boto3.client('lambda').put_function_concurrency(FunctionName=name, ReservedConcurrentExecutions=concurrency)
        print('\nset lambda concurrency to:', concurrency, file=sys.stderr)

def main(path: 'python file that defines the lambda, see cli-aws/examples/lambda*.py',
         memory=128,
         timeout=300,
         concurrency=0,
         *env_vars: 'KEY=VALUE',
         yes=False,
         quick: 'update code only' = False,
         no_encrypt: 'do not kms-encrypt every env var, which is the default when a kms key is specified' = False,
         kms: 'auto create a kms key for this lambda, otherwise default lambda key is used' = False,
         kms_key: 'use a specific kms arn or alias' = None):
    path, lines, metadata = _parse_file(path)
    name = cli_aws.lambda_name(path)
    if quick and os.path.isfile(_zip_file(path)):
        zipfile = _update_zip(path)
        retry(boto3.client('lambda').update_function_code, silent=True, exponent=1.1)(FunctionName=name, ZipFile=zipfile)
        print('\ndone', file=sys.stderr)
    else:
        for var in env_vars:
            assert '=' in var, f'bad env-var, should be: KEY=VALUE, not: {var}'
        arn_user = boto3.client('sts').get_caller_identity()['Arn']
        print(f'arn_user: {arn_user}', file=sys.stderr)
        print(f'file: {path}', file=sys.stderr)
        print(f'names: {name}\n', file=sys.stderr)
        if not yes:
            print('\nproceed? y/n ')
            assert shell.getch() == 'y'
        _ensure_log_group(name)
        arn_role = cli_aws.ensure_role(name, 'lambda')
        cli_aws.ensure_policies(name, metadata['policies'])
        cli_aws.ensure_allows(name, metadata['allows'])
        cli_aws.remove_extra_allows(name, metadata['allows'])
        cli_aws.remove_extra_policies(name, metadata['policies'])
        zipfile = _create_zip(path, metadata['requires'])
        kw = {'FunctionName': name,
              'Runtime': 'python3.6',
              'Role': arn_role,
              'Timeout': timeout,
              'MemorySize': memory,
              'Environment': {'Variables': {k: v for var in env_vars for k, v in [var.split('=', 1)]}},
              'Handler': os.path.basename(path).split('.py')[0] + '.main'}
        if kms_key:
            if not kms_key.startswith('arn:'):
                assert not kms_key.startswith('/'), f'kms key alias should not start with /: {kms_key}'
                assert 'alias' not in kms_key, f'kms key should not contain the word "alias": {kms_key}'
                keys = [x for x in _all_keys() if x['AliasArn'].endswith(f':alias/{kms_key}')]
                assert len(keys) == 1, f'didnt find exactly 1 kms key for alias: {kms_key} => {keys}'
                print(f'using kms key: {kms_key} => {keys[0]["AliasArn"]}')
                kms_key = _key_id(keys[0])
            kw['KMSKeyArn'] = kms_key
        elif kms:
            kw['KMSKeyArn'] = _ensure_key(name, arn_user, arn_role)
        if 'KMSKeyArn' in kw:
            _ensure_key_allows_role(kw['KMSKeyArn'], arn_role)
            if not no_encrypt:
                kw['Environment']['Variables'] = {k: _encrypt(kw['KMSKeyArn'], v) for k, v in kw['Environment']['Variables'].items()}
        try:
            arn_lambda = boto3.client('lambda').get_function(FunctionName=name)['Configuration']['FunctionArn']
        except boto3.client('lambda').exceptions.ResourceNotFoundException:
            arn_lambda = retry(boto3.client('lambda').create_function, silent=True, exponent=1.1)(Code={'ZipFile': zipfile}, **kw)['FunctionArn']
        else:
            retry(boto3.client('lambda').update_function_code, silent=True, exponent=1.1)(FunctionName=name, ZipFile=zipfile)
            retry(boto3.client('lambda').update_function_configuration, silent=True, exponent=1.1)(**kw)
        _ensure_triggers_sns(name, arn_lambda, metadata)
        _ensure_triggers_cloudwatch(name, arn_lambda, metadata)
        _ensure_triggers_api(name, arn_lambda, metadata)
        _set_concurrency(name, concurrency)
        print('\ndone\n', file=sys.stderr)
        return arn_lambda

if __name__ == '__main__':
    with cli_aws.setup():
        argh.dispatch_command(main)
