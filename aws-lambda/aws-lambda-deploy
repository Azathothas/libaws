#!/usr/bin/env python3.6
import base64
import json
import argh
import cli_aws
import tempfile
import sys
import os
import shell
import boto3
from util.retry import retry

def _parse_file(path):
    path = os.path.abspath(path)
    if not os.path.isfile(path):
        print('no such file:', path, file=sys.stderr)
        sys.exit(1)
    if not path.endswith('.py') or len(path.split('.py')) > 2:
        print('usage: python deploy.py some_lambda_file.py', file=sys.stderr)
        sys.exit(1)
    with open(path) as f:
        lines = f.read().splitlines()
    return path, lines, {"policies": cli_aws.parse_metadata('policy:', lines),
                         "allows": cli_aws.parse_metadata('allow:', lines),
                         "requires": cli_aws.parse_metadata('require:', lines),
                         "triggers": cli_aws.parse_metadata('trigger:', lines)}

def _policy_name(allow):
    return allow.replace('*', 'All').replace(' ', '-').replace(':', '--')

def _remove_extra_policies(name, metadata):
    print('\nremove extra policies', file=sys.stderr)
    attached_role_policies = [policy for page in boto3.client('iam').get_paginator('list_attached_role_policies').paginate(RoleName=name) for policy in page['AttachedPolicies']]
    for policy in attached_role_policies:
        if policy['PolicyName'] not in metadata['policies']:
            print('detaching policy:', policy['PolicyName'], file=sys.stderr)
            boto3.client('iam').detach_role_policy(RoleName=name, PolicyArn=policy["PolicyArn"])

def _remove_extra_allows(name, metadata):
    print('\nremove extra allows', file=sys.stderr)
    role_policies = [policy for page in boto3.client('iam').get_paginator('list_role_policies').paginate(RoleName=name) for policy in page['PolicyNames']]
    for policy in role_policies:
        if policy not in [_policy_name(x) for x in metadata['allows']]:
            print('removing policy:', policy, file=sys.stderr)
            shell.run(f'aws iam delete-role-policy --role-name {name} --policy-name {policy}')

def _ensure_triggers_cloudwatch(name, arn_lambda, metadata):
    print('\nensure triggers cloudwatch', file=sys.stderr)
    for trigger in metadata['triggers']:
        if trigger.split()[0] == 'cloudwatch':
            _, schedule = trigger.split(None, 1)
            print(' add cloudwatch rule:', schedule)
            arn_rule = boto3.client('events').put_rule(Name=name, ScheduleExpression=schedule)['RuleArn']
            boto3.client('events').put_targets(Rule=name, Targets=[{'Id': '1', 'Arn': arn_lambda}])
            _ensure_permission(name, 'events.amazonaws.com', arn_rule)

def _ensure_permission(name, principal, arn):
    try:
        statements = [x['Sid'] for x in json.loads(boto3.client('lambda').get_policy(FunctionName=name)['Policy'])['Statement']]
    except boto3.client('lambda').exceptions.ResourceNotFoundException:
        statements = []
    id = principal.replace('.', '-')
    if id in statements:
        print(' trigger permission already exists', file=sys.stderr)
    else:
        print(' add trigger permission:', principal, file=sys.stderr)
        boto3.client('lambda').add_permission(FunctionName=name,
                                              StatementId=id,
                                              Action='lambda:InvokeFunction',
                                              Principal=principal,
                                              SourceArn=arn)

def _ensure_triggers_sns(name, arn_lambda, metadata):
    print('\nensure triggers sns', file=sys.stderr)
    if 'sns' in metadata['triggers']:
        arn_sns = boto3.client('sns').create_topic(Name=name)['TopicArn']
        print('arn-sns:', arn_sns)
        boto3.client('sns').subscribe(TopicArn=arn_sns,
                                      Protocol='lambda',
                                      Endpoint=arn_lambda)
        _ensure_permission(name, 'sns.amazonaws.com', arn_sns)

def _ensure_allows(name, metadata):
    print('\nensure allows', file=sys.stderr)
    for allow in metadata['allows']:
        action, resource = allow.split()
        print(' ensure allow:', allow, file=sys.stderr)
        policy = f'''{{"Version": "2012-10-17",
                       "Statement": [{{"Effect": "Allow",
                                       "Action": "{action}",
                                       "Resource": "{resource}"}}]}}'''
        boto3.client('iam').put_role_policy(RoleName=name, PolicyName=_policy_name(allow), PolicyDocument=policy)

def _ensure_policies(name, metadata):
    print('\nensure policies', file=sys.stderr)
    all_policies = [policy for page in boto3.client('iam').get_paginator('list_policies').paginate() for policy in page['Policies']]
    for policy in metadata['policies']:
        matched_polices = [x for x in all_policies if x['Arn'].split('/')[-1] == policy]
        if 0 == len(matched_polices):
            print(' didnt find any policy:', policy, file=sys.stderr)
            sys.exit(1)
        elif 1 == len(matched_polices):
            boto3.client('iam').attach_role_policy(RoleName=name, PolicyArn=matched_polices[0]["Arn"])
            print(' attached policy:', policy, file=sys.stderr)
        else:
            print(' found more than 1 policy:', policy, file=sys.stderr)
            for p in matched_polices:
                print(p['Arn'], file=sys.stderr)
            sys.exit(1)

def _ensure_role(name):
    print('ensure role', file=sys.stderr)
    role_path = f'/lambda/{name}-path/'
    roles = boto3.client('iam').list_roles(PathPrefix=role_path)['Roles']
    if 0 == len(roles):
        print(' create role:', name, file=sys.stderr)
        policy = '''{"Version": "2012-10-17",
                     "Statement": [{"Effect": "Allow",
                                    "Principal": {"Service": "lambda.amazonaws.com"},
                                    "Action": "sts:AssumeRole"}]}'''
        return boto3.client('iam').create_role(Path=role_path, RoleName=name, AssumeRolePolicyDocument=policy)['Role']['Arn']
    elif 1 == len(roles):
        print(' role exists:', name, file=sys.stderr)
        return roles[0]['Arn']
    else:
        print(' error: there is more than 1 role under path:', role_path, file=sys.stderr)
        for role in roles:
            print('', role, file=sys.stderr)
        sys.exit(1)

def _all_keys():
    return [alias for page in boto3.client('kms').get_paginator('list_aliases').paginate() for alias in page['Aliases']]

def _key_id(key):
    return key['AliasArn'].split(':alias/')[0] + f':key/{key["TargetKeyId"]}'

def _ensure_key(name, arn_user, arn_role):
    print('\nensure kms key:', name, file=sys.stderr)
    keys = [x for x in _all_keys() if x['AliasArn'].endswith(f':alias/lambda/{name}')]
    if 0 == len(keys):
        arn_root = ':'.join(arn_user.split(':')[:-1]) + ':root'
        policy = """
        {"Version": "2012-10-17",
         "Statement": [{"Sid": "Enable IAM User Permissions",
                        "Effect": "Allow",
                        "Principal": {"AWS": ["%(arn_user)s", "%(arn_root)s"]},
                        "Action": "kms:*",
                        "Resource": "*"},
                       {"Sid": "Allow use of the key",
                        "Effect": "Allow",
                        "Principal": {"AWS": ["%(arn_user)s", "%(arn_role)s", "%(arn_root)s"]},
                        "Action": ["kms:Encrypt", "kms:Decrypt", "kms:ReEncrypt*", "kms:GenerateDataKey*", "kms:DescribeKey"],
                        "Resource": "*"},
                       {"Sid": "Allow attachment of persistent resources",
                        "Effect": "Allow",
                        "Principal": {"AWS": ["%(arn_user)s", "%(arn_role)s", "%(arn_root)s"]},
                        "Action": ["kms:CreateGrant", "kms:ListGrants", "kms:RevokeGrant"],
                        "Resource": "*",
                        "Condition": {"Bool": {"kms:GrantIsForAWSResource": true}}}]}
        """ % {'arn_role': arn_role,
               'arn_user': arn_user,
               'arn_root': arn_root}
        key_id = retry(boto3.client('kms').create_key, exponent=1.1, silent=True)(Policy=policy, Description=name)['KeyMetadata']['KeyId']
        boto3.client('kms').create_alias(AliasName=f'alias/lambda/{name}', TargetKeyId=key_id)
        keys = [x for x in _all_keys() if x['AliasArn'].endswith(f':alias/lambda/{name}')]
        assert len(keys) == 1
        print(' created key:', keys[0]['AliasArn'], file=sys.stderr)
        return _key_id(keys[0])
    elif 1 == len(keys):
        print(' key already exists:', keys[0]['AliasArn'], file=sys.stderr)
        return _key_id(keys[0])
    else:
        print(' error: found more than 1 key for:', name, '\n' + '\n'.join(keys), file=sys.stderr)
        sys.exit(1)

def _create_zip(path, metadata):
    print('\ncreate zip', file=sys.stderr)
    tempdir = tempfile.mkdtemp()
    shell.run(f'virtualenv --python python3.6 {tempdir}/env')
    with shell.cd(os.path.dirname(path)):
        shell.run(f'{tempdir}/env/bin/pip install', *metadata['requires'], '2>/dev/null')
    with shell.cd(f'{tempdir}/env/lib/python3.6/site-packages'):
        shell.run(f'cp {path} .')
        shell.run('rm -rf wheel pip setuptools pkg_resources easy_install.py')
        shell.run("ls | grep -E 'info$' | xargs rm -rf")
        shell.run(f'zip -r {tempdir}/lambda.zip .')
    with open(f'{tempdir}/lambda.zip', 'rb') as f:
        val = f.read()
    os.remove(f'{tempdir}/lambda.zip')
    return val

def _encrypt(key_id, text):
    text = bytes(text, 'utf-8')
    text = boto3.client('kms').encrypt(KeyId=key_id, Plaintext=text)['CiphertextBlob']
    return base64.b64encode(text).decode('utf-8')

def _ensure_key_allows_role(key_arn, user_arn):
    resp = boto3.client('kms').get_key_policy(KeyId=key_arn, PolicyName='default')
    policy = json.loads(resp['Policy'])
    for statement in policy['Statement']:
        if statement['Sid'] == 'Allow use of the key':
            if isinstance(statement['Principal']['AWS'], str):
                statement['Principal']['AWS'] = [statement['Principal']['AWS']]
            break
    else:
        assert False, 'something is wrong with your key policy, didnt find a Sid: "Allow use of the key"'
    for statement in policy['Statement']:
        if statement['Sid'] == 'Allow use of the key':
            for arn in statement['Principal']['AWS'].copy():
                if not arn.startswith('arn:'):
                    statement['Principal']['AWS'].remove(arn)
    for statement in policy['Statement']:
        if statement['Sid'] == 'Allow use of the key':
            if user_arn not in statement['Principal']['AWS']:
                statement['Principal']['AWS'].append(user_arn)
            break
    else:
        assert False, 'something is wrong with your key policy, didnt find a Sid: "Allow use of the key"'
    retry(boto3.client('kms').put_key_policy, silent=True, exponent=1.2)(KeyId=key_arn, Policy=json.dumps(policy), PolicyName='default')

def _ensure_log_group(name):
    name = f'/aws/lambda/{name}'
    try:
        boto3.client('logs').create_log_group(logGroupName=name)
        print('created log group:', name, file=sys.stderr)
    except boto3.client('logs').exceptions.ResourceAlreadyExistsException:
        print('log group already exists:', name, file=sys.stderr)

def main(path: 'python file that defines the lambda, see cli-aws/examples/lambda*.py',
         memory=128,
         timeout=300,
         *env_vars: 'KEY=VALUE',
         yes=False,
         no_encrypt: 'do not kms-encrypt every env var, which is the default when a kms key is specified' = False,
         kms: 'auto create a kms key for this lambda, otherwise default lambda key is used' = False,
         kms_key: 'use a specific kms arn or alias' = None):
    for var in env_vars:
        assert var.count('=') == 1, 'bad env-var, should be: KEY=VALUE'
    name = cli_aws.lambda_name(path)
    arn_user = boto3.client('sts').get_caller_identity()['Arn']
    print(f'arn_user: {arn_user}', file=sys.stderr)
    print(f'file: {path}', file=sys.stderr)
    print(f'names: {name}\n', file=sys.stderr)
    path, lines, metadata = _parse_file(path)
    if not yes:
        print('\nproceed? y/n ')
        assert shell.getch() == 'y'
    arn_role = _ensure_role(name)
    _ensure_log_group(name)
    _ensure_policies(name, metadata)
    _ensure_allows(name, metadata)
    _remove_extra_allows(name, metadata)
    _remove_extra_policies(name, metadata)
    # TODO kms costs $1/month per master key, lets make this opt in
    zipfile = _create_zip(path, metadata)
    kw = {'FunctionName': name,
          'Runtime': 'python3.6',
          'Role': arn_role,
          'Timeout': timeout,
          'MemorySize': memory,
          'Environment': {'Variables': {k: v for var in env_vars for k, v in [var.split('=')]}},
          'Handler': os.path.basename(path).split('.py')[0] + '.main'}
    if kms_key:
        if not kms_key.startswith('arn:'):
            assert not kms_key.startswith('/'), f'kms key alias should not start with /: {kms_key}'
            assert 'alias' not in kms_key, f'kms key should not contain the word "alias": {kms_key}'
            keys = [x for x in _all_keys() if x['AliasArn'].endswith(f':alias/{kms_key}')]
            assert len(keys) == 1, f'didnt find exactly 1 kms key for alias: {kms_key} => {keys}'
            print(f'using kms key: {kms_key} => {keys[0]["AliasArn"]}')
            kms_key = _key_id(keys[0])
        kw['KMSKeyArn'] = kms_key
    elif kms:
        kw['KMSKeyArn'] = _ensure_key(name, arn_user, arn_role)
    if 'KMSKeyArn' in kw:
        _ensure_key_allows_role(kw['KMSKeyArn'], arn_role)
        if not no_encrypt:
            kw['Environment']['Variables'] = {k: _encrypt(kw['KMSKeyArn'], v) for k, v in kw['Environment']['Variables'].items()}
    try:
        arn_lambda = boto3.client('lambda').get_function(FunctionName=name)['Configuration']['FunctionArn']
    except boto3.client('lambda').exceptions.ResourceNotFoundException:
        arn_lambda = retry(boto3.client('lambda').create_function, silent=True, exponent=1.1)(Code={'ZipFile': zipfile}, **kw)['FunctionArn']
    else:
        boto3.client('lambda').update_function_code(FunctionName=name, ZipFile=zipfile)
        boto3.client('lambda').update_function_configuration(**kw)
    _ensure_triggers_sns(name, arn_lambda, metadata)
    _ensure_triggers_cloudwatch(name, arn_lambda, metadata)
    print(file=sys.stderr)
    return arn_lambda

if __name__ == '__main__':
    with cli_aws.setup():
        argh.dispatch_command(main)
